
＊＊＊＊＊＊＊＊创建型＊＊＊＊＊＊＊＊＊＊＊

1. 原型模式：Prototype：根据原型创建副本，eg:NSCoping，实现copyWithZone

2. 工厂模式：Factory Method：为多个派生类创建一个实例
    1. 创建工厂，根据不同类型，生产出不同的产品
    2. factory类，定义生产方法；product类，定义生成产品的方法
    3. subProduct继承product，代表不同的产品；subFactory继承factory，代表不同工厂
    4. 创建特定的subFactory，生产出特定的产品
    5. eg：NSNumber

3. 抽象工厂模式：Abstract Factory：为一组类创建实例
    1. 创建超级工厂，根据不同类型，生产出不同的产品工厂，工厂用于生产产品
    2. 类蔟：将若干相关的私有具体工厂子类集合到一个公有的抽象super类之下
    3. 目的：构建简单或复杂产品的套件
    4. eg：NSNumber

4. 建造者模式：Builder：将product的构造和表现分离开来，适用于character比较多的product
    1. 目的：分步构建复杂的产品
    2. 角色：Director、bulider
    3. Builder：分步构建各种character
    4. Director：提供参数让builder构建相关产品
    5. 使用场景：基本部件不变，但其组合经常变动，比如肯德基中的套餐
    6. 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序

5. 单例模式：Singleton：只有一个实例存在


＊＊＊＊＊＊＊＊结构型＊＊＊＊＊＊＊＊＊＊＊＊＊＊

6. 适配器模式：Adapter：使原本由于接口不兼容而不能一起工作的类可以一起工作
    1. 一组类（adaptee）的接口不兼容，为了能够通用，引用适配器作为接口之间的桥梁，
    2. 为了能够通用，引出相关协议（protocol）统一待适配者（adaptee）的这些接口，每个类（adaptee）各自生成一个遵守了协议（protocol）的特定的适配器（adapter）
        1. 两种实现方式：类适配器(继承)、对象适配器(引用)
        1. 类适配器：通过继承adaptee，遵守protocol，调用adaptee的方法去实现protocol中的方法
        2. 对象适配器：引用adaptee，遵守protocol，调用adaptee的方法去实现protocol中的方法
    3. 使用的时候，调用实现了protocol方法的adapter，不直接使用adaptee
    4. 用delegate的方式理解的话，adapter就是代理

7. 桥接模式：Bridge：将一个对象的抽象部分从实现中分离出来
    1. 抽象类：声明了供客户端使用的抽象接口
    2. 实现类：实现了抽象类的底层接口
    4. 实现：使用抽象类处理相关逻辑，抽象类的实现放到具体的子类(实现类)
    5. 桥接：抽象类(逻辑) --引用--> 实现类 --实现接口--> 实现层
    6. eg：开关控制电器
        1. 抽象：开关－－> 开启、关闭接口；电器--> 运行、停止接口；开关 --引用--> 电器实例
        2. 实现：开关开启、关闭的时候，调用电器的运行／暂停功能，不同电器实现各自的运行、停止功能
        3. 调用：开关的开启／关闭

8. 外观模式：Facade：为复杂的子系统提供一个简单的对外接口

9. 组合模式：Composite：将对象组合成树形结构，表示“部分－整体”的层次结构，使用户对单个对象和组合对象的使用具有一致性
    1. 对象具有相同的抽象接口
    2. 整个结构构成抽象结构，实现时不用暴露对象内部接口
    3. eg：UIView

10. 装饰者模式：Decorator：动态的为当前类添加或修改功能
    1. 通过子类方式
    2. 分类

11. 享元模式：FlyWeight：运用共享技术有效的支持大量细粒度的对象
    1. 两个关键组件：可共享的享元对象、对象池
    2. 管理者维护对象池及其中的享元对象
    3. eg：咖啡厅点咖啡
        1. 咖啡种类：享元对象
        2. 菜单：对象池
        3. 咖啡厅：管理者

12. 代理模式：Proxy：为其他对象提供一种代理以控制对这个对象的访问
    1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。
    2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。


＊＊＊＊＊＊＊＊行为型＊＊＊＊＊＊＊＊＊＊＊＊＊＊

13. 模板方法模式：Template：定义操作算法的骨架，而将步骤延迟到子类中
    1. 父类抽象好通用的方法(模版)，处理好整个逻辑，具体由子类实现
    2. 向模板方法增加额外方法：父类添加“钩子”方法
        1. 钩子：空实现方法，用于给子类提供额外操作,子类按需进行相关实现
        2. eg：drawRect

14. 命令模式：Command：将一个请求封装成一个对象
    1. 抽象命令基类command，并生成不同的命令子类执行不同操作
    2. 客户端生成命令，接收器接收并处理命令，真正的执行者执行相关事务

15. 迭代器模式：Iterator：提供顺序访问聚合对象中的各个元素，而又不需要暴露该对象的内部表示
    1. 外部迭代器：直接获取迭代器，通过迭代器便利对象
    2. 内部迭代器：内部封装好，不直接接触到迭代器

16. 观察者模式：Observer：定义对象间一对多的依赖关系，当一个对象状态变化时，所有依赖于它的对象都会得到通知并被自动更新
    1. 发布－订阅机制
    2. 以某种方式组织观察者，及被通知后的处理方法
    3. 触发某事件时，调用观察者的方法
    4. eg：NSNotification，KVO

17. 中介者模式：Mediator：定义一个集中场所，用于简化对象之间的依存关系，中介者集中处理交互逻辑
    1. 用一个对象封装一系列对象的交互方式，使对象之间不必显示的相互饮用，使耦合松散
    2. 中介者引用相关对象，并处理相关逻辑
    3. 对象引用中介者
    4. eg：UINavigationController

18. 备忘录模式：Memento：捕获对象状态并保存，以便之后可以恢复对象原先状态：eg:归档／解挡、plist

19. 解释器模式：Interpreter：对于一些固定文法构建一个解释句子的解释器

20. 状态模式：State：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类
    1. 根据对象的状态改变它的相关行为
    2. 将具体的状态类抽象出来，不同状态对应不同的状态类
    3. eg：UIButton的normal、selected、disable

21. 策略模式：Strategy：定义一系列算法并封装起来，并使它们可互相替换
    1. 使算法独立于使用它的客户而变化
    2. 实现
        1. 抽象策略基类
        2. 实现不同的策略子类及算法
        3. 不同对象中引用对应的策略子类，并调用其算法
    3. 客户端可以使用统一代码进行相关策略计算

22. 责任链模式：Chain Of Responsibility：对象引用同类型的另一个对象，形成链条传递相关任务，直到有对象可以处理
    1. 链中对象实现相同方法
    2. 发起请求后，链中第一个对象进行处理，如果不知道如何处理，就传递到下一个对象，类推

23. 访问者模式：Visitor：表示一个作用于某对象结构中的各元素的操作，让我们可以在不改变各元素的类的前提下定义这些元素的新操作
    1. 数据结构与逻辑分离
    2. 元素(被访问者)：接收访问者进行处理相关逻辑
    3. 访问者：为元素声明抽象接口，不同访问者根据元素的不同处理相关逻辑
